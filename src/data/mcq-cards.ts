import type { MCQCard } from '../types';

export const MCQ_CARDS: MCQCard[] = [
  // ===== ARRAYS & HASHING =====
  { id: 'two-sum-mcq-1', problemId: 'two-sum', difficulty: 'medium',
    question: 'Which approach reduces Two Sum from O(n^2) to O(n)?',
    options: ['Sorting the array then binary search', 'Hash map storing value -> index', 'Two pointers from both ends', 'Prefix sum array'],
    correctIndex: 1, explanation: 'A hash map allows O(1) lookup for the complement (target - num) as you iterate, giving O(n) total time.' },
  { id: 'two-sum-mcq-2', problemId: 'two-sum', difficulty: 'hard',
    question: 'For nums = [3, 3], target = 6, what does the hash map approach return?',
    options: ['[0, 0]', '[0, 1]', 'Error: duplicate keys overwrite', 'Empty array'],
    correctIndex: 1, explanation: 'When processing index 1, we check if 6-3=3 exists in the map. It does (index 0), so we return [0, 1]. We check BEFORE inserting, so no overwrite issue.' },
  { id: 'two-sum-mcq-3', problemId: 'two-sum', difficulty: 'hard',
    question: 'Why can\'t you sort the array and use two pointers for Two Sum when you need to return original indices?',
    options: ['Sorting is O(n log n) which is too slow', 'Sorting destroys the original index mapping', 'Two pointers only works on positive numbers', 'Two pointers can\'t handle duplicates'],
    correctIndex: 1, explanation: 'Sorting rearranges elements, losing original indices. You\'d need to store original indices alongside values, adding complexity. Hash map is simpler.' },

  { id: 'group-anagrams-mcq-1', problemId: 'group-anagrams', difficulty: 'medium',
    question: 'What is the most efficient key strategy for grouping anagrams?',
    options: ['Sort each string alphabetically', 'Character frequency count as tuple/string', 'Hash of character XOR values', 'Compare all pairs of strings'],
    correctIndex: 1, explanation: 'Character frequency count gives O(k) per string vs O(k log k) for sorting. Use counts like "1#0#0#...#0" as keys.' },
  { id: 'group-anagrams-mcq-2', problemId: 'group-anagrams', difficulty: 'hard',
    question: 'For input ["eat","tea","tan","ate","nat","bat"], how many groups are formed?',
    options: ['2', '3', '4', '6'],
    correctIndex: 1, explanation: 'Three groups: ["eat","tea","ate"], ["tan","nat"], ["bat"]. Anagrams share the same sorted characters.' },
  { id: 'group-anagrams-mcq-3', problemId: 'group-anagrams', difficulty: 'hard',
    question: 'Why is using XOR of character codes a bad key for grouping anagrams?',
    options: ['XOR is too slow to compute', 'Different strings can have the same XOR value (collisions)', 'XOR doesn\'t work with Unicode', 'XOR produces negative values'],
    correctIndex: 1, explanation: '"ab" and "ba" would match (good), but "ad" and "bc" could also collide since XOR loses count information.' },

  { id: 'longest-consecutive-mcq-1', problemId: 'longest-consecutive-sequence', difficulty: 'medium',
    question: 'How do you achieve O(n) for Longest Consecutive Sequence?',
    options: ['Sort then linear scan', 'Hash set + only count from sequence starts', 'Union-Find on consecutive pairs', 'BFS from every element'],
    correctIndex: 1, explanation: 'Put all numbers in a Set. Only start counting when (num-1) is NOT in the set. Each number is visited at most twice total.' },
  { id: 'longest-consecutive-mcq-2', problemId: 'longest-consecutive-sequence', difficulty: 'hard',
    question: 'For nums = [100, 4, 200, 1, 3, 2], what is the longest consecutive sequence length?',
    options: ['3', '4', '5', '6'],
    correctIndex: 1, explanation: 'The sequence [1, 2, 3, 4] has length 4. The numbers 100 and 200 are isolated.' },
  { id: 'longest-consecutive-mcq-3', problemId: 'longest-consecutive-sequence', difficulty: 'hard',
    question: 'Why is the hash set solution O(n) despite having a while loop inside a for loop?',
    options: ['The while loop runs at most log(n) times', 'Each element is visited by the inner loop at most once across ALL iterations', 'The for loop skips most elements', 'Hash set lookups are O(1) amortized'],
    correctIndex: 1, explanation: 'Only sequence starts trigger the while loop. Each number participates in at most one sequence count. Total inner loop iterations across all outer iterations is at most n.' },

  { id: 'contains-duplicate-mcq-1', problemId: 'contains-duplicate', difficulty: 'medium',
    question: 'Which approach detects duplicates in O(n) time and O(n) space?',
    options: ['Sort then check adjacent elements', 'Hash Set - add and check each element', 'Nested loops comparing all pairs', 'Bit manipulation with XOR'],
    correctIndex: 1, explanation: 'A Set provides O(1) lookup. For each element, check if it\'s in the set; if yes, duplicate found. If no, add it.' },
  { id: 'contains-duplicate-mcq-2', problemId: 'contains-duplicate', difficulty: 'hard',
    question: 'You have nums = [1, 2, 3, 1]. At which iteration does the Set approach detect the duplicate?',
    options: ['Iteration 1 (value 1)', 'Iteration 2 (value 2)', 'Iteration 3 (value 3)', 'Iteration 4 (value 1)'],
    correctIndex: 3, explanation: 'At iteration 4, we check if 1 is in the set {1,2,3}. It is, so we return true. The first three iterations just add to the set.' },

  { id: 'product-except-self-mcq-1', problemId: 'product-of-array-except-self', difficulty: 'medium',
    question: 'How do you solve Product of Array Except Self without division?',
    options: ['Prefix product * suffix product for each index', 'Nested loop multiplying all except current', 'Sort then use cumulative products', 'Use logarithms to convert to addition'],
    correctIndex: 0, explanation: 'Build prefix products (left to right) and suffix products (right to left). result[i] = prefix[i] * suffix[i].' },
  { id: 'product-except-self-mcq-2', problemId: 'product-of-array-except-self', difficulty: 'hard',
    question: 'For nums = [1, 2, 3, 4], what is output[2] (product except self at index 2)?',
    options: ['6', '8', '12', '24'],
    correctIndex: 1, explanation: 'Product of all elements except index 2 (value 3): 1 * 2 * 4 = 8.' },
  { id: 'product-except-self-mcq-3', problemId: 'product-of-array-except-self', difficulty: 'hard',
    question: 'Why does the division approach fail for Product of Array Except Self?',
    options: ['Division is O(n^2)', 'It fails when any element is zero', 'Division causes floating point errors', 'It requires extra space'],
    correctIndex: 1, explanation: 'If any element is 0, total product is 0 and you can\'t divide by 0. You\'d need special handling for zero counts.' },

  { id: 'valid-anagram-mcq-1', problemId: 'valid-anagram', difficulty: 'medium',
    question: 'What is the optimal approach for checking if two strings are anagrams?',
    options: ['Sort both strings and compare', 'Character frequency count array', 'XOR all characters together', 'Use a stack to match characters'],
    correctIndex: 1, explanation: 'A 26-element frequency array gives O(n) time. Increment for string 1, decrement for string 2, check all zeros.' },
  { id: 'valid-anagram-mcq-2', problemId: 'valid-anagram', difficulty: 'hard',
    question: 'If s = "anagram" and t = "nagaram", what should every count in the frequency array be after processing both?',
    options: ['26', '1', '0', '-1'],
    correctIndex: 2, explanation: 'For each character, incrementing for s and decrementing for t should cancel out to 0 if they are anagrams.' },

  { id: 'top-k-frequent-mcq-1', problemId: 'top-k-frequent-elements', difficulty: 'medium',
    question: 'Which approach gives O(n) time for Top K Frequent Elements?',
    options: ['Sort by frequency', 'Min-heap of size k', 'Bucket sort where index = frequency', 'Quickselect on frequencies'],
    correctIndex: 2, explanation: 'Bucket sort: create array of size n+1 where index = frequency. Fill buckets, then collect from highest bucket. O(n) time.' },
  { id: 'top-k-frequent-mcq-2', problemId: 'top-k-frequent-elements', difficulty: 'hard',
    question: 'For nums = [1,1,1,2,2,3], k = 2, what does the bucket sort approach return?',
    options: ['[1, 2]', '[2, 3]', '[1, 3]', '[3, 2]'],
    correctIndex: 0, explanation: 'Frequencies: 1->3, 2->2, 3->1. Buckets: index 3 has [1], index 2 has [2], index 1 has [3]. Taking top 2: [1, 2].' },

  // ===== TWO POINTERS =====
  { id: 'container-water-mcq-1', problemId: 'container-with-most-water', difficulty: 'medium',
    question: 'Why does the two-pointer approach work for Container With Most Water?',
    options: ['It always picks the tallest lines', 'Moving the shorter pointer can only improve the area', 'It checks all possible pairs efficiently', 'The width always decreases so we maximize height'],
    correctIndex: 1, explanation: 'The shorter line limits the area. Moving it inward might find a taller line and increase area. Moving the taller line can only decrease or maintain area (width shrinks).' },
  { id: 'container-water-mcq-2', problemId: 'container-with-most-water', difficulty: 'hard',
    question: 'For height = [1,8,6,2,5,4,8,3,7], what is the maximum water area?',
    options: ['36', '40', '49', '56'],
    correctIndex: 2, explanation: 'Between indices 1 (h=8) and 8 (h=7): min(8,7) * (8-1) = 7 * 7 = 49.' },

  { id: '3sum-mcq-1', problemId: '3sum', difficulty: 'medium',
    question: 'What is the key step to solve 3Sum in O(n^2)?',
    options: ['Hash map for complement lookup', 'Sort array then use two pointers for each fixed element', 'Three nested loops with early termination', 'Divide and conquer on the sorted array'],
    correctIndex: 1, explanation: 'Sort the array. Fix one element, then use two pointers on the remaining subarray to find pairs that sum to its negation.' },
  { id: '3sum-mcq-2', problemId: '3sum', difficulty: 'hard',
    question: 'In 3Sum, how do you avoid duplicate triplets?',
    options: ['Use a Set to store results', 'Skip duplicate values when moving each pointer', 'Only consider unique elements', 'Sort results and remove duplicates at the end'],
    correctIndex: 1, explanation: 'After finding a valid triplet, skip duplicate values for the fixed element and both pointers (while nums[i] == nums[i-1], skip).' },
  { id: '3sum-mcq-3', problemId: '3sum', difficulty: 'hard',
    question: 'For nums = [-1, 0, 1, 2, -1, -4], how many unique triplets sum to 0?',
    options: ['1', '2', '3', '4'],
    correctIndex: 1, explanation: 'Two triplets: [-1, -1, 2] and [-1, 0, 1]. After sorting: [-4, -1, -1, 0, 1, 2].' },

  { id: 'trapping-rain-mcq-1', problemId: 'trapping-rain-water', difficulty: 'hard',
    question: 'In the two-pointer approach for Trapping Rain Water, what determines how much water a position holds?',
    options: ['min(leftMax, rightMax) - height[i]', 'max(leftMax, rightMax) - height[i]', 'leftMax + rightMax - height[i]', 'abs(leftMax - rightMax)'],
    correctIndex: 0, explanation: 'Water at position i is bounded by the shorter of the two max heights on either side, minus the ground height at i.' },
  { id: 'trapping-rain-mcq-2', problemId: 'trapping-rain-water', difficulty: 'hard',
    question: 'For height = [0,1,0,2,1,0,1,3,2,1,2,1], how much water is trapped?',
    options: ['4', '5', '6', '8'],
    correctIndex: 2, explanation: 'The trapped water is 6 units. Each position contributes: min(leftMax, rightMax) - height[i] when positive.' },

  { id: 'valid-palindrome-mcq-1', problemId: 'valid-palindrome', difficulty: 'medium',
    question: 'What is the key technique for checking palindromes with non-alphanumeric characters?',
    options: ['Remove all non-alphanumeric chars first', 'Two pointers that skip non-alphanumeric chars', 'Reverse the string and compare', 'Use regex replacement then compare'],
    correctIndex: 1, explanation: 'Two pointers from both ends, skipping non-alphanumeric characters and comparing case-insensitively. O(n) time, O(1) space.' },

  { id: 'two-sum-ii-mcq-1', problemId: 'two-sum-ii', difficulty: 'medium',
    question: 'Why do two pointers work for Two Sum II on a sorted array?',
    options: ['Pointers move toward each other, narrowing the search', 'If sum > target, right pointer decreases sum; if sum < target, left pointer increases sum', 'Sorted arrays have no duplicates', 'Binary search is embedded in the pointer movement'],
    correctIndex: 1, explanation: 'Since the array is sorted, moving left pointer right increases the sum, and moving right pointer left decreases it. This gives a systematic way to find the target.' },

  // ===== SLIDING WINDOW =====
  { id: 'longest-substring-mcq-1', problemId: 'longest-substring-without-repeating-characters', difficulty: 'medium',
    question: 'What data structure tracks characters in the current window for Longest Substring Without Repeating Characters?',
    options: ['Array of 26 booleans', 'Hash Set of characters', 'Hash Map of character -> last index', 'Queue of characters'],
    correctIndex: 2, explanation: 'A hash map storing character -> last seen index lets you jump the left pointer directly to one past the duplicate, avoiding char-by-char shrinking.' },
  { id: 'longest-substring-mcq-2', problemId: 'longest-substring-without-repeating-characters', difficulty: 'hard',
    question: 'For s = "abcabcbb", what is the length of the longest substring without repeating characters?',
    options: ['2', '3', '4', '5'],
    correctIndex: 1, explanation: 'The answer is 3 ("abc"). When we hit the second "a", the window resets.' },

  { id: 'min-window-substr-mcq-1', problemId: 'minimum-window-substring', difficulty: 'hard',
    question: 'In Minimum Window Substring, when do you shrink the window?',
    options: ['When window size exceeds t.length', 'When all characters of t are satisfied in the window', 'When a duplicate character is found', 'After every expansion step'],
    correctIndex: 1, explanation: 'Expand right until all of t\'s characters are satisfied, then shrink from left to minimize. Track satisfaction with a counter of matched characters.' },
  { id: 'min-window-substr-mcq-2', problemId: 'minimum-window-substring', difficulty: 'hard',
    question: 'For s = "ADOBECODEBANC", t = "ABC", what is the minimum window substring?',
    options: ['"ADOBEC"', '"BANC"', '"BECODEBA"', '"CODEBA"'],
    correctIndex: 1, explanation: '"BANC" (length 4) is the smallest window containing A, B, and C.' },

  { id: 'best-buy-sell-mcq-1', problemId: 'best-time-to-buy-and-sell-stock', difficulty: 'medium',
    question: 'What is the key insight for Best Time to Buy and Sell Stock in O(n)?',
    options: ['Track max price seen so far', 'Track min price seen so far, compute profit at each step', 'Use two pointers from both ends', 'Sort prices and take difference of max and min'],
    correctIndex: 1, explanation: 'Track the minimum price seen. At each price, compute profit = current - minSoFar. Track max profit across all steps.' },
  { id: 'best-buy-sell-mcq-2', problemId: 'best-time-to-buy-and-sell-stock', difficulty: 'hard',
    question: 'For prices = [7,1,5,3,6,4], what is the maximum profit?',
    options: ['4', '5', '6', '7'],
    correctIndex: 1, explanation: 'Buy at 1 (day 2), sell at 6 (day 5). Profit = 6 - 1 = 5.' },

  { id: 'longest-repeating-mcq-1', problemId: 'longest-repeating-character-replacement', difficulty: 'hard',
    question: 'In Longest Repeating Character Replacement with k replacements, what condition triggers window shrinking?',
    options: ['Window size > 26', 'Window size - count of most frequent char > k', 'Number of distinct chars > k', 'Any character count exceeds k'],
    correctIndex: 1, explanation: 'windowLength - maxFreqCount > k means we need more than k replacements. Shrink the window from the left.' },

  // ===== STACK =====
  { id: 'valid-parens-mcq-1', problemId: 'valid-parentheses', difficulty: 'medium',
    question: 'Why is a stack the ideal data structure for Valid Parentheses?',
    options: ['Stacks support O(1) search', 'LIFO order matches nested bracket closing order', 'Stacks can store pairs of brackets', 'Stacks automatically validate nesting'],
    correctIndex: 1, explanation: 'The most recently opened bracket must be closed first (LIFO). Push opening brackets, pop and match on closing brackets.' },
  { id: 'valid-parens-mcq-2', problemId: 'valid-parentheses', difficulty: 'hard',
    question: 'For s = "([)]", is it valid?',
    options: ['Yes, all brackets are matched', 'No, brackets are improperly nested', 'Yes, each type appears equal times', 'Depends on the implementation'],
    correctIndex: 1, explanation: 'Opening "[" would need to close before "(". When we see ")", the stack top is "[" which doesn\'t match.' },

  // ===== BINARY SEARCH =====
  { id: 'search-rotated-mcq-1', problemId: 'search-in-rotated-sorted-array', difficulty: 'hard',
    question: 'In Search in Rotated Sorted Array, how do you decide which half to search?',
    options: ['Always search the larger half', 'Determine which half is sorted, then check if target is in that range', 'Compare target with the pivot element', 'Use two binary searches: find pivot, then search'],
    correctIndex: 1, explanation: 'If nums[left] <= nums[mid], left half is sorted. Check if target is in [left, mid]. Otherwise, right half is sorted. This works in a single binary search.' },
  { id: 'search-rotated-mcq-2', problemId: 'search-in-rotated-sorted-array', difficulty: 'hard',
    question: 'For nums = [4,5,6,7,0,1,2], target = 0, what index is returned?',
    options: ['0', '3', '4', '6'],
    correctIndex: 2, explanation: '0 is at index 4. Binary search identifies the right half as containing the target.' },

  { id: 'find-min-rotated-mcq-1', problemId: 'find-minimum-in-rotated-sorted-array', difficulty: 'hard',
    question: 'In Find Minimum in Rotated Sorted Array, what does nums[mid] > nums[right] tell you?',
    options: ['Minimum is in the left half', 'Minimum is in the right half (mid+1 to right)', 'Mid is the minimum', 'Array is not rotated'],
    correctIndex: 1, explanation: 'If nums[mid] > nums[right], the rotation point (minimum) must be between mid+1 and right.' },

  // ===== LINKED LIST =====
  { id: 'remove-nth-mcq-1', problemId: 'remove-nth-node-from-end-of-list', difficulty: 'medium',
    question: 'How do you remove the nth node from the end in one pass?',
    options: ['Count length first, then traverse again', 'Use two pointers with n gap between them', 'Use a stack to store all nodes', 'Reverse the list first'],
    correctIndex: 1, explanation: 'Advance the fast pointer n steps ahead. Then move both pointers until fast reaches the end. Slow is now at the node before the target.' },

  { id: 'merge-sorted-mcq-1', problemId: 'merge-two-sorted-lists', difficulty: 'medium',
    question: 'What is the key to merging two sorted linked lists?',
    options: ['Convert to arrays, merge, convert back', 'Compare heads, attach smaller, advance that pointer', 'Always attach from list 1 first', 'Use a priority queue'],
    correctIndex: 1, explanation: 'Use a dummy head. Compare current nodes of both lists, attach the smaller one, advance that list\'s pointer. O(n+m) time.' },

  { id: 'merge-k-mcq-1', problemId: 'merge-k-sorted-lists', difficulty: 'hard',
    question: 'What is the optimal approach for Merge K Sorted Lists?',
    options: ['Merge all lists sequentially one by one', 'Min-heap of size k holding current heads', 'Convert all to one array and sort', 'Divide and conquer: pairwise merge'],
    correctIndex: 1, explanation: 'A min-heap of k current heads gives O(N log k) where N is total nodes. Always extract min and push next node from that list.' },
  { id: 'merge-k-mcq-2', problemId: 'merge-k-sorted-lists', difficulty: 'hard',
    question: 'Why is merging k lists one by one O(Nk) instead of O(N log k)?',
    options: ['Each merge doubles the list size, so later merges process more nodes', 'Sequential merge doesn\'t use a heap', 'The first list gets traversed k-1 times', 'One-by-one merge can\'t handle duplicates efficiently'],
    correctIndex: 0, explanation: 'Merging list 1+2 creates a list of size ~2n. Merging that with list 3 processes ~3n nodes. Total: 2n + 3n + ... + kn = O(Nk).' },

  { id: 'linked-list-cycle-mcq-1', problemId: 'linked-list-cycle', difficulty: 'medium',
    question: 'How does Floyd\'s cycle detection (tortoise and hare) work?',
    options: ['Mark visited nodes with a flag', 'Fast pointer moves 2 steps, slow moves 1; they meet if cycle exists', 'Store all node addresses in a Set', 'Reverse the list and check if head is reached again'],
    correctIndex: 1, explanation: 'If there\'s a cycle, the fast pointer (2x speed) will eventually catch the slow pointer inside the cycle. O(1) space.' },

  { id: 'reorder-list-mcq-1', problemId: 'reorder-list', difficulty: 'hard',
    question: 'What are the three steps to reorder a linked list L0->L1->...->Ln to L0->Ln->L1->Ln-1...?',
    options: ['Reverse then merge', 'Find middle, reverse second half, merge alternately', 'Use a deque to interleave', 'Copy to array, rearrange, rebuild list'],
    correctIndex: 1, explanation: 'Find middle (slow/fast pointers), reverse the second half, then merge the two halves by alternating nodes.' },

  { id: 'reverse-ll-mcq-1', problemId: 'reverse-linked-list', difficulty: 'medium',
    question: 'In iterative linked list reversal, how many pointers do you need?',
    options: ['1 (current)', '2 (prev, current)', '3 (prev, current, next)', '4 (head, prev, current, next)'],
    correctIndex: 2, explanation: 'You need prev (initially null), current, and next (saved before reversing). At each step: save next, reverse pointer, advance prev and current.' },

  // ===== TREES =====
  { id: 'validate-bst-mcq-1', problemId: 'validate-binary-search-tree', difficulty: 'hard',
    question: 'Why is checking node.left.val < node.val < node.right.val insufficient for BST validation?',
    options: ['It doesn\'t handle null nodes', 'It only checks immediate children, not all descendants', 'BSTs allow equal values', 'It doesn\'t work with negative numbers'],
    correctIndex: 1, explanation: 'A node in the left subtree could be greater than an ancestor. You need to pass min/max bounds down the tree.' },

  { id: 'level-order-mcq-1', problemId: 'binary-tree-level-order-traversal', difficulty: 'medium',
    question: 'Which data structure is used for level order traversal?',
    options: ['Stack', 'Queue', 'Priority Queue', 'Hash Map'],
    correctIndex: 1, explanation: 'BFS uses a queue. Process all nodes at current level (queue size), pushing their children for the next level.' },

  { id: 'max-depth-mcq-1', problemId: 'maximum-depth-of-binary-tree', difficulty: 'medium',
    question: 'What is the recursive formula for max depth of a binary tree?',
    options: ['1 + left.depth + right.depth', '1 + max(left.depth, right.depth)', 'max(left.depth, right.depth)', '1 + min(left.depth, right.depth)'],
    correctIndex: 1, explanation: 'Max depth = 1 (current node) + maximum of left and right subtree depths. Base case: null node returns 0.' },

  { id: 'construct-tree-mcq-1', problemId: 'construct-binary-tree-from-preorder-and-inorder-traversal', difficulty: 'hard',
    question: 'In constructing a tree from preorder and inorder traversals, what does the first preorder element tell you?',
    options: ['The leftmost leaf', 'The root of the current subtree', 'The rightmost node', 'The tree depth'],
    correctIndex: 1, explanation: 'Preorder visits root first. Find this root in inorder to split into left and right subtrees. Recurse on each half.' },

  { id: 'max-path-sum-mcq-1', problemId: 'binary-tree-maximum-path-sum', difficulty: 'hard',
    question: 'In Binary Tree Maximum Path Sum, why can\'t you return the path through both children to the parent?',
    options: ['It would be too slow', 'A path through both children forms a "V" which can\'t extend upward', 'Children might be null', 'The sum might be negative'],
    correctIndex: 1, explanation: 'A path that goes left-child -> node -> right-child can\'t also go to the parent (would visit the node twice). So we return max(left, right) + node to parent, but track the V-path as a candidate answer.' },

  { id: 'invert-tree-mcq-1', problemId: 'invert-binary-tree', difficulty: 'medium',
    question: 'What does inverting a binary tree mean?',
    options: ['Reverse the values in-order', 'Swap left and right children at every node', 'Rotate the tree 180 degrees', 'Mirror only the leaf nodes'],
    correctIndex: 1, explanation: 'Recursively swap left and right children at every node. The result is a mirror image of the original tree.' },

  { id: 'kth-smallest-bst-mcq-1', problemId: 'kth-smallest-element-in-a-bst', difficulty: 'medium',
    question: 'Which traversal gives BST elements in sorted order?',
    options: ['Preorder', 'Inorder', 'Postorder', 'Level order'],
    correctIndex: 1, explanation: 'Inorder traversal of a BST visits nodes in ascending order. The kth element visited is the kth smallest.' },

  { id: 'lca-bst-mcq-1', problemId: 'lowest-common-ancestor-of-a-bst', difficulty: 'medium',
    question: 'How do you find LCA in a BST efficiently?',
    options: ['Find paths to both nodes and compare', 'If both values < node, go left; if both > node, go right; otherwise current is LCA', 'Do BFS and find the deepest common parent', 'Use parent pointers'],
    correctIndex: 1, explanation: 'BST property: if p and q are on different sides (or one equals current), current node is the LCA. O(h) time.' },

  { id: 'serialize-tree-mcq-1', problemId: 'serialize-and-deserialize-binary-tree', difficulty: 'hard',
    question: 'Why do you need null markers when serializing a binary tree?',
    options: ['To preserve the tree shape', 'To handle duplicate values', 'To mark leaf nodes', 'To reduce string length'],
    correctIndex: 0, explanation: 'Without null markers, you can\'t distinguish between different tree structures that have the same values. Nulls encode the exact shape.' },

  { id: 'subtree-mcq-1', problemId: 'subtree-of-another-tree', difficulty: 'hard',
    question: 'What is the time complexity of the naive recursive subtree check?',
    options: ['O(n)', 'O(m)', 'O(n * m)', 'O(n + m)'],
    correctIndex: 2, explanation: 'For each of n nodes in the main tree, we might compare up to m nodes of the subtree. Worst case O(n * m).' },

  // ===== TRIE =====
  { id: 'trie-mcq-1', problemId: 'implement-trie-prefix-tree', difficulty: 'medium',
    question: 'What is the space complexity of a Trie storing n words of average length k?',
    options: ['O(n)', 'O(n * k)', 'O(26^k)', 'O(n * k * 26)'],
    correctIndex: 1, explanation: 'In the worst case (no shared prefixes), each word needs k nodes. With shared prefixes, actual usage is less. Each node has up to 26 children pointers.' },

  { id: 'word-dict-mcq-1', problemId: 'design-add-and-search-words-data-structure', difficulty: 'hard',
    question: 'How do you handle the "." wildcard in word search with a Trie?',
    options: ['Replace "." with all 26 letters and search each', 'At ".", branch to ALL children recursively', 'Skip the "." level entirely', 'Use regex on serialized Trie'],
    correctIndex: 1, explanation: 'When encountering ".", try all 26 possible children. If any path succeeds, return true. This is essentially DFS with branching at wildcards.' },

  { id: 'word-search-ii-mcq-1', problemId: 'word-search-ii', difficulty: 'hard',
    question: 'Why is a Trie better than checking each word individually in Word Search II?',
    options: ['Tries use less memory', 'Shared prefixes are searched once instead of repeated DFS per word', 'Tries support wildcards', 'Tries are faster to build'],
    correctIndex: 1, explanation: 'Multiple words with shared prefixes reuse the same DFS path. Without a Trie, each word triggers a full DFS. Trie prunes entire branches early.' },

  // ===== HEAP =====
  { id: 'find-median-mcq-1', problemId: 'find-median-from-data-stream', difficulty: 'hard',
    question: 'Which data structure combination finds the running median efficiently?',
    options: ['Sorted array with binary insertion', 'Max-heap for lower half + min-heap for upper half', 'AVL tree with order statistics', 'Hash map of value -> count'],
    correctIndex: 1, explanation: 'Max-heap stores the smaller half, min-heap stores the larger half. Median is the top of one or average of both tops. O(log n) per insertion.' },
  { id: 'find-median-mcq-2', problemId: 'find-median-from-data-stream', difficulty: 'hard',
    question: 'After adding [2, 3, 4] to the median stream, what are the heap tops?',
    options: ['MaxHeap: 2, MinHeap: 4', 'MaxHeap: 3, MinHeap: 4', 'MaxHeap: 2, MinHeap: 3', 'MaxHeap: 3, MinHeap: 3'],
    correctIndex: 1, explanation: 'Lower half (max-heap): [2, 3], top=3. Upper half (min-heap): [4], top=4. Median = 3 (odd count, take from larger heap).' },

  // ===== BACKTRACKING =====
  { id: 'combination-sum-mcq-1', problemId: 'combination-sum', difficulty: 'medium',
    question: 'In Combination Sum, how do you allow reusing the same number?',
    options: ['Start the next recursion from index 0', 'Start from the current index (not i+1)', 'Use a visited array', 'Add the number multiple times before recursing'],
    correctIndex: 1, explanation: 'By recursing with the same index i (not i+1), we allow the same candidate to be used again. Moving to i+1 would prevent reuse.' },
  { id: 'combination-sum-mcq-2', problemId: 'combination-sum', difficulty: 'hard',
    question: 'For candidates = [2, 3, 6, 7], target = 7, how many combinations exist?',
    options: ['1', '2', '3', '4'],
    correctIndex: 1, explanation: 'Two combinations: [2, 2, 3] and [7].' },

  { id: 'word-search-mcq-1', problemId: 'word-search', difficulty: 'hard',
    question: 'In Word Search on a grid, why must you mark cells as visited during DFS?',
    options: ['To improve time complexity', 'To prevent using the same cell twice in one path', 'To avoid infinite loops in cycles', 'To track which words are found'],
    correctIndex: 1, explanation: 'Each cell can only be used once per word path. Mark as visited before exploring neighbors, unmark when backtracking.' },

  // ===== GRAPHS =====
  { id: 'clone-graph-mcq-1', problemId: 'clone-graph', difficulty: 'medium',
    question: 'What prevents infinite loops when cloning a graph with cycles?',
    options: ['Using BFS instead of DFS', 'A hash map from original node -> cloned node', 'Processing each edge only once', 'Sorting nodes by value first'],
    correctIndex: 1, explanation: 'The map serves as both a "visited" check and a way to reuse already-cloned nodes. If a node is in the map, return the clone instead of recursing.' },

  { id: 'num-islands-mcq-1', problemId: 'number-of-islands', difficulty: 'medium',
    question: 'What is the time complexity of BFS/DFS for Number of Islands on an m x n grid?',
    options: ['O(m * n)', 'O(m + n)', 'O(m * n * 4)', 'O((m * n)^2)'],
    correctIndex: 0, explanation: 'Each cell is visited at most once (marked as visited). The 4-directional check per cell is constant. Total: O(m * n).' },
  { id: 'num-islands-mcq-2', problemId: 'number-of-islands', difficulty: 'hard',
    question: 'For grid = [["1","1","0"],["1","1","0"],["0","0","1"]], how many islands?',
    options: ['1', '2', '3', '4'],
    correctIndex: 1, explanation: 'Two islands: the 2x2 block of 1s in the top-left, and the single 1 in the bottom-right.' },

  { id: 'course-schedule-mcq-1', problemId: 'course-schedule', difficulty: 'medium',
    question: 'Course Schedule is essentially detecting what in a directed graph?',
    options: ['Connected components', 'Shortest path', 'Cycles', 'Bridges'],
    correctIndex: 2, explanation: 'If there\'s a cycle in the prerequisite graph, you can\'t complete all courses. Use topological sort or DFS cycle detection.' },
  { id: 'course-schedule-mcq-2', problemId: 'course-schedule', difficulty: 'hard',
    question: 'In DFS cycle detection, what do the three node states (unvisited, in-progress, completed) represent?',
    options: ['BFS layers', 'Node colors in graph coloring', 'White: unvisited, Gray: in current DFS path, Black: fully explored', 'Priority levels for processing'],
    correctIndex: 2, explanation: 'Encountering a gray node during DFS means we\'ve found a back edge (cycle). Black nodes are safe - their subtree has no cycles.' },

  { id: 'graph-valid-tree-mcq-1', problemId: 'graph-valid-tree', difficulty: 'hard',
    question: 'A graph is a valid tree if and only if:',
    options: ['It has n-1 edges', 'It is connected and has no cycles', 'Every node has at most 2 children', 'It has exactly one root node'],
    correctIndex: 1, explanation: 'A tree is a connected acyclic graph. Equivalently: n nodes, n-1 edges, and connected. Having n-1 edges alone isn\'t sufficient (could be disconnected).' },

  { id: 'connected-components-mcq-1', problemId: 'number-of-connected-components-in-an-undirected-graph', difficulty: 'medium',
    question: 'Which approach efficiently counts connected components?',
    options: ['Floyd-Warshall all-pairs shortest path', 'Union-Find (Disjoint Set Union)', 'Dijkstra from every node', 'Adjacency matrix multiplication'],
    correctIndex: 1, explanation: 'Union-Find with path compression and union by rank gives near O(n) for n union/find operations. DFS/BFS also works in O(V+E).' },

  { id: 'pacific-atlantic-mcq-1', problemId: 'pacific-atlantic-water-flow', difficulty: 'hard',
    question: 'Why is it better to BFS from the oceans inward rather than from each cell outward?',
    options: ['BFS is faster than DFS', 'Starting from oceans, you traverse uphill and avoid redundant work', 'Ocean cells are easier to identify', 'Inward BFS uses less memory'],
    correctIndex: 1, explanation: 'BFS from ocean borders marks all cells that can reach that ocean. The intersection of Pacific-reachable and Atlantic-reachable cells is the answer. Each cell is visited at most twice.' },

  // ===== 1D DP =====
  { id: 'longest-palindrome-substr-mcq-1', problemId: 'longest-palindromic-substring', difficulty: 'medium',
    question: 'What is the expand-around-center approach for Longest Palindromic Substring?',
    options: ['Check all substrings with two pointers', 'For each center (and between-center), expand outward while chars match', 'Use DP table to mark palindromes', 'Reverse string and find longest common substring'],
    correctIndex: 1, explanation: 'Try each of 2n-1 centers (each char + each gap). Expand outward while characters match. O(n^2) time, O(1) space.' },

  { id: 'climbing-stairs-mcq-1', problemId: 'climbing-stairs', difficulty: 'medium',
    question: 'Climbing Stairs is equivalent to which famous sequence?',
    options: ['Catalan numbers', 'Fibonacci sequence', 'Pascal\'s triangle', 'Prime numbers'],
    correctIndex: 1, explanation: 'f(n) = f(n-1) + f(n-2), same as Fibonacci. From step n-1 take 1 step, or from step n-2 take 2 steps.' },
  { id: 'climbing-stairs-mcq-2', problemId: 'climbing-stairs', difficulty: 'hard',
    question: 'How many ways to climb 5 stairs (1 or 2 steps at a time)?',
    options: ['5', '7', '8', '13'],
    correctIndex: 2, explanation: 'f(1)=1, f(2)=2, f(3)=3, f(4)=5, f(5)=8. It follows the Fibonacci pattern.' },

  { id: 'decode-ways-mcq-1', problemId: 'decode-ways', difficulty: 'hard',
    question: 'In Decode Ways, why does "06" have 0 decodings but "6" has 1?',
    options: ['Leading zeros are invalid in the encoding', '06 is not between 1-26', '0 has no letter mapping, so "06" can\'t start a valid decode', 'Both have the same number of decodings'],
    correctIndex: 2, explanation: '"0" doesn\'t map to any letter (A=1). So "06" can\'t be decoded: "0" alone is invalid, and "06" is not a valid two-digit code.' },

  { id: 'word-break-mcq-1', problemId: 'word-break', difficulty: 'medium',
    question: 'What DP approach solves Word Break?',
    options: ['dp[i] = true if s[0..i] can be segmented into dictionary words', 'dp[i][j] = true if s[i..j] is in the dictionary', 'Greedy: always match the longest word', 'Trie + backtracking'],
    correctIndex: 0, explanation: 'dp[i] is true if s[0..i] can be broken. For each i, check all j < i: if dp[j] is true and s[j..i] is in dict, then dp[i] = true.' },

  { id: 'max-product-subarray-mcq-1', problemId: 'maximum-product-subarray', difficulty: 'hard',
    question: 'Why do you need to track both max AND min product at each position?',
    options: ['To handle arrays with all negatives', 'A negative min * negative number becomes the new max', 'To optimize space complexity', 'To handle zeros in the array'],
    correctIndex: 1, explanation: 'A large negative product can become the largest positive product when multiplied by another negative. Track both and swap when current element is negative.' },
  { id: 'max-product-subarray-mcq-2', problemId: 'maximum-product-subarray', difficulty: 'hard',
    question: 'For nums = [2, 3, -2, 4], what is the maximum product subarray?',
    options: ['4', '6', '8', '24'],
    correctIndex: 1, explanation: 'The subarray [2, 3] gives product 6. Including -2 makes it negative, and [4] alone is only 4.' },

  { id: 'house-robber-mcq-1', problemId: 'house-robber', difficulty: 'medium',
    question: 'What is the recurrence for House Robber?',
    options: ['dp[i] = dp[i-1] + nums[i]', 'dp[i] = max(dp[i-1], dp[i-2] + nums[i])', 'dp[i] = max(nums[i], dp[i-1])', 'dp[i] = dp[i-2] + nums[i]'],
    correctIndex: 1, explanation: 'At each house: either skip it (dp[i-1]) or rob it (dp[i-2] + nums[i], since adjacent houses can\'t both be robbed).' },
  { id: 'house-robber-mcq-2', problemId: 'house-robber', difficulty: 'hard',
    question: 'For nums = [2, 7, 9, 3, 1], what is the maximum amount?',
    options: ['10', '11', '12', '13'],
    correctIndex: 2, explanation: 'Rob houses with values 2 + 9 + 1 = 12. Alternatively, 7 + 3 = 10. The optimal is 12.' },

  { id: 'house-robber-ii-mcq-1', problemId: 'house-robber-ii', difficulty: 'hard',
    question: 'How does House Robber II differ from House Robber I?',
    options: ['Houses have different values', 'Houses are in a circle so first and last are adjacent', 'You can rob 2 adjacent houses', 'There are two rows of houses'],
    correctIndex: 1, explanation: 'Run House Robber I twice: once on nums[0..n-2] and once on nums[1..n-1]. Take the max. This handles the circular constraint.' },

  { id: 'lis-mcq-1', problemId: 'longest-increasing-subsequence', difficulty: 'medium',
    question: 'What is the O(n log n) approach for Longest Increasing Subsequence?',
    options: ['DP with binary search on a "tails" array', 'Merge sort modified to count inversions', 'Segment tree with point updates', 'Two pointers on sorted array'],
    correctIndex: 0, explanation: 'Maintain an array "tails" where tails[i] is the smallest tail element of all increasing subsequences of length i+1. Binary search to find insertion point.' },
  { id: 'lis-mcq-2', problemId: 'longest-increasing-subsequence', difficulty: 'hard',
    question: 'For nums = [10, 9, 2, 5, 3, 7, 101, 18], what is the LIS length?',
    options: ['3', '4', '5', '6'],
    correctIndex: 1, explanation: 'One LIS is [2, 3, 7, 101] with length 4. Another is [2, 5, 7, 101].' },

  { id: 'coin-change-mcq-1', problemId: 'coin-change', difficulty: 'medium',
    question: 'What does dp[i] represent in the Coin Change problem?',
    options: ['Number of ways to make amount i', 'Minimum coins to make amount i', 'Whether amount i is achievable', 'Maximum coins to make amount i'],
    correctIndex: 1, explanation: 'dp[i] = minimum number of coins needed to make amount i. dp[amount] is the answer. Initialize dp[0] = 0, rest = Infinity.' },
  { id: 'coin-change-mcq-2', problemId: 'coin-change', difficulty: 'hard',
    question: 'For coins = [1, 3, 4], amount = 6, what is the minimum number of coins?',
    options: ['2', '3', '4', '6'],
    correctIndex: 0, explanation: '3 + 3 = 6 using 2 coins. Greedy (4 + 1 + 1) would give 3 coins. DP finds the optimal.' },

  { id: 'palindromic-substr-mcq-1', problemId: 'palindromic-substrings', difficulty: 'hard',
    question: 'For s = "aaa", how many palindromic substrings exist?',
    options: ['3', '4', '5', '6'],
    correctIndex: 3, explanation: '"a"(x3) + "aa"(x2) + "aaa"(x1) = 6 palindromic substrings.' },

  // ===== 2D DP =====
  { id: 'unique-paths-mcq-1', problemId: 'unique-paths', difficulty: 'medium',
    question: 'What is the recurrence for Unique Paths on an m x n grid?',
    options: ['dp[i][j] = dp[i-1][j] * dp[i][j-1]', 'dp[i][j] = dp[i-1][j] + dp[i][j-1]', 'dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1', 'dp[i][j] = max(dp[i-1][j], dp[i][j-1])'],
    correctIndex: 1, explanation: 'Each cell can be reached from above or from the left. Total paths = sum of paths from both directions.' },
  { id: 'unique-paths-mcq-2', problemId: 'unique-paths', difficulty: 'hard',
    question: 'For a 3x7 grid, how many unique paths exist?',
    options: ['21', '28', '35', '42'],
    correctIndex: 1, explanation: 'C(m+n-2, m-1) = C(8, 2) = 28. It\'s a combinatorics problem: choose 2 "downs" from 8 total moves.' },

  { id: 'lcs-mcq-1', problemId: 'longest-common-subsequence', difficulty: 'medium',
    question: 'What is the recurrence for Longest Common Subsequence?',
    options: ['If chars match: dp[i-1][j-1] + 1; else: max(dp[i-1][j], dp[i][j-1])', 'If chars match: dp[i-1][j-1] + 1; else: 0', 'dp[i][j] = dp[i-1][j] + dp[i][j-1]', 'If chars match: max(dp[i-1][j], dp[i][j-1]) + 1; else: 0'],
    correctIndex: 0, explanation: 'When characters match, extend the LCS. When they don\'t, take the max of skipping either character.' },
  { id: 'lcs-mcq-2', problemId: 'longest-common-subsequence', difficulty: 'hard',
    question: 'For text1 = "abcde", text2 = "ace", what is the LCS length?',
    options: ['1', '2', '3', '4'],
    correctIndex: 2, explanation: 'The LCS is "ace" with length 3.' },

  // ===== GREEDY =====
  { id: 'max-subarray-mcq-1', problemId: 'maximum-subarray', difficulty: 'medium',
    question: 'What is Kadane\'s algorithm\'s key insight?',
    options: ['Sort the array first', 'At each position, either extend the current subarray or start fresh', 'Use divide and conquer on the midpoint', 'Track prefix sums and find max difference'],
    correctIndex: 1, explanation: 'currentMax = max(nums[i], currentMax + nums[i]). If extending the subarray gives less than starting fresh, start fresh.' },
  { id: 'max-subarray-mcq-2', problemId: 'maximum-subarray', difficulty: 'hard',
    question: 'For nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4], what is the max subarray sum?',
    options: ['4', '5', '6', '7'],
    correctIndex: 2, explanation: 'Subarray [4, -1, 2, 1] has sum 6.' },

  { id: 'jump-game-mcq-1', problemId: 'jump-game', difficulty: 'medium',
    question: 'What greedy strategy solves Jump Game in O(n)?',
    options: ['Always jump the maximum distance', 'Track the farthest reachable index, update as you go', 'BFS from index 0', 'DP with dp[i] = can reach index i'],
    correctIndex: 1, explanation: 'Maintain maxReach. For each index i <= maxReach, update maxReach = max(maxReach, i + nums[i]). If maxReach >= n-1, return true.' },

  // ===== INTERVALS =====
  { id: 'merge-intervals-mcq-1', problemId: 'merge-intervals', difficulty: 'medium',
    question: 'What is the first step in Merge Intervals?',
    options: ['Sort by end time', 'Sort by start time', 'Sort by interval length', 'Group overlapping intervals with a hash map'],
    correctIndex: 1, explanation: 'Sort by start time. Then iterate: if current overlaps with last merged interval, extend the end. Otherwise, add as new interval.' },
  { id: 'merge-intervals-mcq-2', problemId: 'merge-intervals', difficulty: 'hard',
    question: 'For intervals = [[1,3],[2,6],[8,10],[15,18]], what are the merged intervals?',
    options: ['[[1,6],[8,10],[15,18]]', '[[1,6],[8,18]]', '[[1,10],[15,18]]', '[[1,18]]'],
    correctIndex: 0, explanation: '[1,3] and [2,6] overlap -> [1,6]. [8,10] and [15,18] don\'t overlap with anything else.' },

  { id: 'insert-interval-mcq-1', problemId: 'insert-interval', difficulty: 'hard',
    question: 'In Insert Interval, what are the three phases of the algorithm?',
    options: ['Sort, merge, output', 'Add all before, merge overlapping, add all after', 'Binary search, insert, merge neighbors', 'Compare starts, compare ends, combine'],
    correctIndex: 1, explanation: 'Add intervals that end before new interval starts. Merge all overlapping with new interval. Add remaining intervals.' },

  { id: 'meeting-rooms-mcq-1', problemId: 'meeting-rooms', difficulty: 'medium',
    question: 'How do you check if a person can attend all meetings?',
    options: ['Check all pairs for overlap', 'Sort by start time, check if any meeting starts before previous ends', 'Count total meeting hours', 'Use interval tree'],
    correctIndex: 1, explanation: 'Sort by start time. If intervals[i].start < intervals[i-1].end for any i, there\'s a conflict.' },

  { id: 'meeting-rooms-ii-mcq-1', problemId: 'meeting-rooms-ii', difficulty: 'hard',
    question: 'How do you find the minimum number of meeting rooms needed?',
    options: ['Count maximum overlapping intervals at any point', 'Sort by start, use min-heap of end times', 'Graph coloring on conflict graph', 'All of the above work'],
    correctIndex: 3, explanation: 'All work. The heap approach: sort by start, push end times to min-heap. If new meeting starts after heap top, pop (reuse room). Heap size = rooms needed.' },
  { id: 'meeting-rooms-ii-mcq-2', problemId: 'meeting-rooms-ii', difficulty: 'hard',
    question: 'For meetings [[0,30],[5,10],[15,20]], how many rooms are needed?',
    options: ['1', '2', '3', '4'],
    correctIndex: 1, explanation: '[0,30] overlaps with [5,10] (need 2 rooms). But [15,20] can reuse the room from [5,10] since 15 >= 10. So 2 rooms.' },

  { id: 'non-overlapping-mcq-1', problemId: 'non-overlapping-intervals', difficulty: 'hard',
    question: 'To minimize removals for Non-overlapping Intervals, which interval should you keep when two overlap?',
    options: ['The longer one', 'The shorter one', 'The one that ends earlier', 'The one that starts earlier'],
    correctIndex: 2, explanation: 'Keep the interval that ends earliest - it leaves the most room for future intervals. This is the classic interval scheduling greedy.' },

  // ===== MATH & GEOMETRY =====
  { id: 'rotate-image-mcq-1', problemId: 'rotate-image', difficulty: 'medium',
    question: 'How do you rotate a matrix 90 degrees clockwise in-place?',
    options: ['Transpose then reverse each row', 'Reverse each row then transpose', 'Rotate layer by layer from outside in', 'Transpose then reverse each column'],
    correctIndex: 0, explanation: 'Transpose (swap matrix[i][j] with matrix[j][i]) then reverse each row. This achieves 90-degree clockwise rotation.' },

  { id: 'spiral-matrix-mcq-1', problemId: 'spiral-matrix', difficulty: 'hard',
    question: 'For a 3x3 matrix [[1,2,3],[4,5,6],[7,8,9]], what is the spiral order?',
    options: ['[1,2,3,6,9,8,7,4,5]', '[1,2,3,4,5,6,7,8,9]', '[1,4,7,8,9,6,3,2,5]', '[1,2,3,6,5,4,7,8,9]'],
    correctIndex: 0, explanation: 'Spiral: right across top (1,2,3), down right (6,9), left across bottom (8,7), up left (4), then center (5).' },

  { id: 'set-matrix-zeroes-mcq-1', problemId: 'set-matrix-zeroes', difficulty: 'medium',
    question: 'How do you solve Set Matrix Zeroes in O(1) extra space?',
    options: ['Use the first row and column as markers', 'Process zeros in reverse order', 'Use bit manipulation on the matrix values', 'Two passes with in-place XOR marking'],
    correctIndex: 0, explanation: 'Use first row/column to mark which rows/columns should be zeroed. Use a separate flag for whether the first row/column itself should be zeroed.' },

  // ===== BIT MANIPULATION =====
  { id: 'reverse-bits-mcq-1', problemId: 'reverse-bits', difficulty: 'medium',
    question: 'How do you reverse bits of a 32-bit integer?',
    options: ['Convert to string, reverse, convert back', 'Iterate 32 times: extract LSB, shift into result from left', 'XOR with 0xFFFFFFFF', 'Swap adjacent bits, then pairs, then nibbles, etc.'],
    correctIndex: 1, explanation: 'Extract the least significant bit (n & 1), shift result left and OR with it, then shift n right. Repeat 32 times.' },

  { id: 'num-1-bits-mcq-1', problemId: 'number-of-1-bits', difficulty: 'medium',
    question: 'What does n & (n - 1) do?',
    options: ['Flips all bits', 'Removes the lowest set bit', 'Checks if n is a power of 2', 'Doubles the value'],
    correctIndex: 1, explanation: 'n & (n-1) clears the lowest set bit. Count how many times you can do this until n becomes 0 to count set bits.' },

  { id: 'missing-number-mcq-1', problemId: 'missing-number', difficulty: 'medium',
    question: 'How do you find the missing number in [0, n] using bit manipulation?',
    options: ['XOR all numbers with all indices 0..n', 'AND all numbers together', 'OR all numbers together', 'NOT of the sum'],
    correctIndex: 0, explanation: 'XOR of a ^ a = 0. XOR all array values with 0,1,...,n. All pairs cancel except the missing number.' },
  { id: 'missing-number-mcq-2', problemId: 'missing-number', difficulty: 'hard',
    question: 'For nums = [3, 0, 1], what is the missing number and how does XOR find it?',
    options: ['2; XOR(0^1^3) ^ XOR(0^1^2^3) = 2', '4; sum formula', '2; sort and find gap', '2; hash set difference'],
    correctIndex: 0, explanation: 'XOR all values: 3^0^1 = 2. XOR with indices: 0^1^2^3 = 0. Total: 2^0 = 2. The unpaired number remains.' },

  { id: 'counting-bits-mcq-1', problemId: 'counting-bits', difficulty: 'medium',
    question: 'What is the DP relation for counting bits of every number from 0 to n?',
    options: ['dp[i] = dp[i/2] + (i & 1)', 'dp[i] = dp[i-1] + 1', 'dp[i] = dp[i & (i-1)] + 1', 'Both A and C work'],
    correctIndex: 3, explanation: 'dp[i>>1] + (i&1): right-shift removes LSB, add it back. dp[i & (i-1)] + 1: remove lowest set bit, add 1. Both are valid O(n) approaches.' },

  { id: 'sum-two-integers-mcq-1', problemId: 'sum-of-two-integers', difficulty: 'hard',
    question: 'How do you add two integers without using + or -?',
    options: ['Use multiplication and division', 'XOR for sum without carry, AND + left shift for carry, repeat', 'Use bitwise NOT and increment', 'Use logarithms: exp(log(a) + log(b))'],
    correctIndex: 1, explanation: 'a XOR b gives sum without carry. (a AND b) << 1 gives the carry. Repeat until carry is 0.' },
  { id: 'sum-two-integers-mcq-2', problemId: 'sum-of-two-integers', difficulty: 'hard',
    question: 'To compute 5 + 3 using bit manipulation: 5 = 101, 3 = 011. What is XOR and carry after step 1?',
    options: ['XOR = 110 (6), Carry = 010 (2)', 'XOR = 111 (7), Carry = 001 (1)', 'XOR = 100 (4), Carry = 010 (2)', 'XOR = 000 (0), Carry = 1000 (8)'],
    correctIndex: 0, explanation: '101 XOR 011 = 110 (6). (101 AND 011) << 1 = 001 << 1 = 010 (2). Next: 110 XOR 010 = 100, carry = (110 AND 010) << 1 = 100. Then 100 XOR 100 = 000, carry = 1000. Finally 1000 XOR 000 = 1000 = 8. Correct!' },

  { id: 'same-tree-mcq-1', problemId: 'same-tree', difficulty: 'medium',
    question: 'What are the base cases for checking if two trees are the same?',
    options: ['Both null: true. One null: false. Values differ: false.', 'Both null: false. One null: true.', 'Only check leaf nodes', 'Compare level by level with BFS'],
    correctIndex: 0, explanation: 'Both null = same (true). One null, other not = different (false). Both non-null with different values = false. Otherwise recurse on left and right.' },
];
